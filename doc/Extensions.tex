%!TEX root = ttc14-fixml.tex

\section{Extensions}
\label{sec:Extensions}

\subsection{Extension 1 - Selection of Appropriate Data Types}
\label{sec:Extension1}

The aim of the first extension is to further refine the data types used by the XML node attributes and use more appropriate types than just a generic string.
The source concerning this is located in the \href{https://github.com/fikovnik/ttc14-fixml-sigma/tree/master/ttc14-fixml-extension-1}{\texttt{ttc14-fixml-extension-1}} directory.

There are three changes needed in order to implement this extension.
\begin{itemize}[(1)]
	\item The first one is in the ObjLang meta-model where we need to add new expression classes representing literals for the new data types.
	In this extension we consider the following new data types: \Scala{double}, \Scala{long} and \Scala{integer}.
	While this list does not cover all the possible XML Schema data types, it provides a good basis for demonstrating how some support for additional ones could be added.

	\item The second one is in the M2M transformation where we need to add the necessary support for guessing the data type of an attribute based on the string values from all of the same-tag siblings that have the attribute in question.
	Following is the code snippet that realizes it:
	%
	\begin{scalacode}
	  // basic types
	  val DTString = DataType(name = "string")
	  val DTDouble = DataType(name = "double")
	  val DTLong = DataType(name = "long")
	  val DTInteger = DataType(name = "int")

	  // it also stores the promotion ordering from right to left
	  val Builtins = Seq(DTString, DTDouble, DTLong, DTInteger)

	  private val PDouble = """([+-]?\d+.\d+)""".r
	  private val PInteger = """([+-]?\d+)""".r

	  def guessDataType(value: String): DataType = value match {
	    case PDouble(_) => DTDouble
	    case PInteger(_) => Try(Integer.parseInt(value)) map (_ => DTInteger) getOrElse (DTLong)
	    case _ => DTString
	  }

	  def guessDataType(values: Seq[String]): DataType =
	    values map guessDataType reduce { (a, b) =>
	      if (Builtins.indexOf(a) < Builtins.indexOf(a)) a else b
	    }
	\end{scalacode}

	\item Finally, we need to update the code transformers to generate the appropriate data types.
	For example, in the C++ generator:
	\begin{scalacode}
override def class2Code(p: DataType) = {
  import XMLMM2ObjLang._
  p match {
    case DTString => "std::string"
    case DTDouble => "double"
    case DTLong => "long"
    case DTInteger => "int"
  }
}		
	\end{scalacode}

\end{itemize}




\subsection{Extension 2 - Extension to Additional Languages}
\label{sec:Extension2}

\Todo{Extension 2}


The source concerning the extension 2 solution is in the \href{https://github.com/fikovnik/ttc14-fixml-sigma/tree/master/ttc14-fixml-extension-2}{\texttt{ttc14-fixml-extension-2}} directory.


\subsection{Extension 3 - Generic Transformation}
\label{sec:Extension3}

\Todo{Extension 3}


The source concerning the extension 3 solution is in the \href{https://github.com/fikovnik/ttc14-fixml-sigma/tree/master/ttc14-fixml-extension-3}{\texttt{ttc14-fixml-extension-3}} directory.
