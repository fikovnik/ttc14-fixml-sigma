%!TEX root = ttc14-fixml.tex

\section{Listings}

\subsection{Transformation Rules}
\label{sec:TransformationRules}

\begin{scalacode}
def ruleXMLNode2DefaultConstructor(s: XMLNode, t: Constructor) {
  s.allSameSiblings foreach (associate(_, t))
}
\end{scalacode}

\begin{scalacode}
def ruleXMLNode2NonDefaultConstructor(s: XMLNode, t: Constructor) = guardedBy {
  !s.isEmptyLeaf
} transform {

  s.allSameSiblings foreach (associate(_, t))

  for (e <- (s.allAttributes ++ s.allSubnodes.distinctBy(_.tag))) {
    val param = e.sTarget[Parameter]
    val field = e.sTarget[Field]

    t.parameters += param
    t.initialisations += FieldInitialisiation(
      field = field,
      expression = ParameterAccess(parameter = param))
  }
}
\end{scalacode}

\begin{scalacode}
def ruleXMLAttribute2ConstructorParameter(s: XMLAttribute, t: Parameter) {
  t.name = checkName(s.name)
  t.type_ = s.sTarget[Field].type_
}
\end{scalacode}

\begin{scalacode}
def ruleXMLNode2ConstructorParameter(s: XMLNode, t: Parameter) {
  val field = s.sTarget[Field]

  t.name = field.name
  t.many = field.many
  t.type_ = field.type_
}
\end{scalacode}

\begin{scalacode}
@LazyUnique
def ruleXMLAttribute2Field(s: XMLAttribute, t: Field) {
  t.name = checkName(s.name)

  t.type_ = DTString
  t.initialValue = StringLiteral(s.value)
}
\end{scalacode}

\begin{scalacode}
@LazyUnique
def ruleXMLNode2Field(s: XMLNode, t: Field) {
  val allSiblings = s.allSameSiblings
  allSiblings foreach (associate(_, t))

  t.type_ = s.sTarget[Class]

  val groups = (s +: allSiblings) groupBy (_.eContainer)
  val max = groups.values map (_.size) max

  if (max > 1) {
    t.name = s.tag + "_objects"
    t.many = true
    val init = ArrayLiteral(type_ = s.sTarget[Class])
    val siblings = groups(s.eContainer)
    
    init.elements ++= siblings.sTarget[ConstructorCall]
    init.elements ++= 0 until (max - siblings.size) map (_ => NullLiteral())
    t.initialValue = init
  } else {
    t.name = s.tag + "_object"
    t.initialValue = s.sTarget[ConstructorCall]
  }
}  
\end{scalacode}

\begin{scalacode}
@Lazy
def ruleXMLNode2ConstructorCall(s: XMLNode, t: ConstructorCall) {
  val constructor = s.sTargets[Constructor]
    .find { c =>
      (c.parameters.isEmpty && s.isEmptyLeaf) ||
      (c.parameters.nonEmpty && !s.isEmptyLeaf)
    }
    .get

  t.constructor = constructor

  t.arguments ++= {
    for {
      param <- constructor.parameters
      source = param.sSource.get
    } yield {
      source match {
        case attr: XMLAttribute =>
          // we can cast since attributes have always primitive types
          val dataType = param.type_.asInstanceOf[DataType]

          s.attributes
            .find(_.name == attr.name)
            .map { local => StringLiteral(local.value) }
            .getOrElse(NullLiteral())

        case node: XMLNode =>
          s.subnodes.filter(_.tag == node.tag) match {

            case Seq() if !param.many =>
              NullLiteral()
            case Seq(x) if !param.many =>
              x.sTarget[ConstructorCall]
            case Seq(xs @ _*) =>
              val groups = (node +: node.allSameSiblings) groupBy (_.eContainer)
              val max = groups.values map (_.size) max
              
              val init = ArrayLiteral(type_ = param.type_)
              init.elements ++= xs.sTarget[ConstructorCall]
              init.elements ++= 0 until (max - xs.size) map (_ => NullLiteral())
              init
          }
      }
    }
  }
}
\end{scalacode}