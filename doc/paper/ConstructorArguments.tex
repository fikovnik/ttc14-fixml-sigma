%!TEX root = ttc14-fixml.tex

\section{Handling Constructor Arguments}
\label{sec:ConstructorArguments}

The number of same-tag sibling nodes can vary within a parent node.
For example:

\inputminted[fontsize=\fontsize{8}{8},linenos,numbersep=5pt,frame=lines,framesep=2mm]{xml}{listings/variable-siblings.xml}

The \Scala|Sub| should be represented by an array field and the default initialization of \Scala|PosRpt| should equal to the following (in Java):
%
\begin{javacode}
public Pty[] Pty_objects = new Pty[] { 
  new Pty("OCC", "21", null, new Sub[] { null, null }),
  new Pty("C", "38", null, new Sub[] { new Sub("ZZZ", "2", null), null }),
  new Pty("C", "38", "Q", new Sub[] { new Sub("ZZZ", "2", null), new Sub("ZZZ", "3", "X") }) 
};
\end{javacode}
%
Note that the first and second instances of \Scala|Pty| contains two and one \Scala|null| respectively in the place of missing \Scala|Sub| subnode.

The \Scala|ConstructorCall| used for field initializations in the \Scala|ruleXMLNode2Field| is created from an XML node using the last rule in the transformation:
%
\begin{scalacode}
@Lazy
def ruleXMLNode2ConstructorCall(s: XMLNode, t: ConstructorCall) {
  val constructor = s.sTargets[Constructor]
    .find { c =>
      (c.parameters.isEmpty && s.isEmptyLeaf) ||
      (c.parameters.nonEmpty && !s.isEmptyLeaf)
    }
    .get

  t.constructor = constructor

  t.arguments ++= {
    for {
      param <- constructor.parameters
      source = param.sSource.get
    } yield {
      source match {
        case attr: XMLAttribute =>
          // we can cast since attributes have always primitive types
          val dataType = param.type_.asInstanceOf[DataType]

          s.attributes
            .find(_.name == attr.name)
            .map { local => StringLiteral(local.value) }
            .getOrElse(NullLiteral())

        case node: XMLNode =>
          s.subnodes.filter(_.tag == node.tag) match {

            case Seq() if !param.many =>
              NullLiteral()
            case Seq(x) if !param.many =>
              x.sTarget[ConstructorCall]
            case Seq(xs @ _*) =>
              val groups = (node +: node.allSameSiblings) groupBy (_.eContainer)
              val max = groups.values map (_.size) max
              
              val init = ArrayLiteral(type_ = param.type_)
              init.elements ++= xs.sTarget[ConstructorCall]
              init.elements ++= 0 until (max - xs.size) map (_ => NullLiteral())
              init
          }
      }
    }
  }
}
\end{scalacode}  

First we need to find which constructor shall be used depending whether the given XML node (or any of its same-tag siblings) contains any attributes or subnodes.
Next, we need to resolve the arguments for the case of non-default constructor.
We do this by using the sources, \Ie, the source elements (XML node or XML attribute) that were used to create the constructor parameters.
\SIGMA provides \Scala|sSource| method that is the inverse of \Scala|sTarget| call with the difference that it will not trigger any rule execution.
In the pattern matching we need to cover all possible cases such as an attribute defined locally or an attribute defined in a same-tag sibling, thus using \Scala|null| for its initialization.
